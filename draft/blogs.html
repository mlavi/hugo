<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>blogs</title>
  </head>
  <body>
    Short blog ideas:<br>
    <ol>
      <li>Dev env container layers + production: immutable challenges<br>
      </li>
      <li>Microservices</li>
      <li>CD and autoscale examples: with Ajit?</li>
      <li>Ephemeral devops vision</li>
    </ol>
    <hr size="2" width="100%">
    <h1>Demystifying Microservices</h1>
    <p>As functionality increases, software complexity grows. The
      simplest metric to measure the increase of work is lines of code,
      but it is much harder to discern the work it takes to manage an
      ever increasing code base. The danger of using this simple metric
      is that it doesn't measure the work to change existing lines of
      code and does not reward the reduction of lines of code, making
      the code easier to maintain. It is hard to define the impact of
      refactoring software because there can be many different and
      potentially conflicting goals for optimization: speed versus
      maintainability versus instrumentation versus testability versus
      deployability versus dynamic configuration? Every organization
      will answer these questions in a unique way, but when viewing
      software development in context of DevOps, the answer becomes much
      clearer: you optimize for removing friction to deliver value to
      the customer. So the prioritization of all refactoring and
      development work can be aligned to a DevOps goal.<br>
    </p>
    <p>Adopting a DevOps culture breaks down the traditional barriers in
      an engineering organization to accomplish this goal when we
      recognize that refactoring work was siloed, for example:</p>
    <ol>
      <li>software developers worked to refactor functionality into
        modular components to facilitate code reuse and speed
        development.</li>
      <li>database administrators worked on data design to accomplish
        data reuse, security, and access speed.</li>
      <li>quality and testing teams have evolved like software
        developers in order to reuse base test cases and speed testing
        results.</li>
      <li>operations teams automate their work with configuration
        management, monitoring, logging, and metric systems.</li>
    </ol>
    <p>All of these efforts are worthy, but when they are made in
      parallel without a common goal, it will be unlikely to
      revolutionize engineering value.<br>
    </p>
    <p>DevOps culture is the solution! Because the entire software value
      chain is examined for frictionless life cycle delivery, all of the
      teams can unite to prioritize and coordinate their work under one
      goal. This goal can be unlock new efficiencies across the entire
      engineering organization when adopting microservices delivered by
      containers.</p>
    <p>In my previous blog entry about CI/CD, I briefly discussed the
      challenges of refactoring the monolith:</p>
    <ul>
      <li>Quote</li>
    </ul>
    <p>The benefits of allowing each software developer and team iterate
      on their own cadence reduces the need for coordination with other
      teams and removes friction for continuous deployment to the
      customer. This architectural practice is the embodiment of the web
      standards and it has been proven to scale by Amazon (the leading
      retailer and public cloud provider) and Netflix (the leading
      streaming video provider) for many applications, here are some
      references.</p>
    <p>Calm is an ideal platform for modeling your applications,
      refactoring application architectures to microservices and
      infrastructures across providers, and managing container clusters.
      Let us show you how!<br>
    </p>
  </body>
</html>
